import { AxelarRecoveryAPIConfig, EvmWalletDetails, AddGasOptions, TxResult, QueryGasFeeOptions, ApproveGatewayError, GMPRecoveryResponse, AxelarTxResponse, Environment } from "../types";
import { EvmChain } from "../../constants/EvmChain";
import { AxelarRecoveryApi } from "./AxelarRecoveryApi";
import { AxelarQueryAPI } from "../AxelarQueryAPI";
import { EventResponse } from "@axelar-network/axelarjs-types/axelar/evm/v1beta1/query";
import { ChainInfo } from "src/chains/types";
import { Coin, OfflineSigner } from "@cosmjs/proto-signing";
import { DeliverTxResponse, SigningStargateClient, StdFee } from "@cosmjs/stargate";
import { JsonRpcProvider } from "@ethersproject/providers";
export declare const GMPErrorMap: Record<string, ApproveGatewayError>;
interface ConfirmTxSDKResponse {
    success: boolean;
    errorMessage?: string;
    infoLogs: string[];
    commandId: string;
    confirmTx?: AxelarTxResponse;
    eventResponse?: EventResponse;
}
interface SignTxSDKResponse {
    success: boolean;
    errorMessage?: string;
    signCommandTx?: AxelarTxResponse;
    infoLogs: string[];
}
interface BroadcastTxSDKResponse {
    success: boolean;
    errorMessage?: string;
    approveTx?: AxelarTxResponse;
    infoLogs: string[];
}
export declare enum RouteDir {
    COSMOS_TO_EVM = "cosmos_to_evm",
    EVM_TO_COSMOS = "evm_to_cosmos",
    EVM_TO_EVM = "evm_to_evm",
    COSMOS_TO_COSMOS = "cosmos_to_cosmos"
}
export declare type SendOptions = {
    txFee: StdFee;
    environment: Environment;
    offlineSigner: OfflineSigner;
    rpcUrl?: string;
    timeoutTimestamp?: number;
};
export declare type AutocalculateGasOptions = {
    gasMultipler?: number;
};
export declare type AddGasParams = {
    txHash: string;
    chain: string;
    token: Coin | "autocalculate";
    sendOptions: SendOptions;
    gasLimit: number;
    autocalculateGasOptions?: AutocalculateGasOptions;
};
export declare type AddGasResponse = {
    success: boolean;
    info: string;
    broadcastResult?: DeliverTxResponse;
};
export declare type GetFullFeeOptions = {
    environment: Environment;
    autocalculateGasOptions?: AutocalculateGasOptions | undefined;
    tx: any;
    chainConfig: any;
};
export declare const getCosmosSigner: (rpcUrl: string, offlineDirectSigner: OfflineSigner) => Promise<SigningStargateClient>;
export declare class AxelarGMPRecoveryAPI extends AxelarRecoveryApi {
    axelarQueryApi: AxelarQueryAPI;
    private staticInfo;
    constructor(config: AxelarRecoveryAPIConfig);
    getCidFromSrcTxHash(destChainId: string, messageId: string, eventIndex: number): string;
    doesTxMeetConfirmHt(chain: string, txHash: string, provider?: JsonRpcProvider): Promise<boolean | undefined>;
    isEVMEventFailed(eventResponse: EventResponse | undefined): boolean | undefined;
    isEVMEventConfirmed(eventResponse: EventResponse): boolean | undefined;
    isEVMEventCompleted(eventResponse: EventResponse): boolean | undefined;
    getEvmEvent(srcChainId: string, destChainId: string, srcTxHash: string, srcTxEventIndex: number | undefined, evmWalletDetails?: EvmWalletDetails): Promise<{
        commandId: string;
        eventResponse: EventResponse;
        success: boolean;
        errorMessage: string;
        infoLog: string;
    }>;
    findEventAndConfirmIfNeeded(srcChain: string, destChain: string, txHash: string, txEventIndex: number | undefined, evmWalletDetails: EvmWalletDetails): Promise<ConfirmTxSDKResponse>;
    findBatchAndSignIfNeeded(commandId: string, destChainId: string): Promise<SignTxSDKResponse>;
    findBatchAndApproveGateway(commandId: string, destChainId: string, wallet: EvmWalletDetails): Promise<BroadcastTxSDKResponse>;
    manualRelayToDestChain(txHash: string, txLogIndex?: number | undefined, txEventIndex?: number | undefined, evmWalletDetails?: EvmWalletDetails, escapeAfterConfirm?: boolean, messageId?: string): Promise<GMPRecoveryResponse>;
    getRouteDir(srcChain: ChainInfo, destChain: ChainInfo): RouteDir;
    private recoverCosmosToCosmosTx;
    private recoverEvmToCosmosTx;
    private recoverCosmosToEvmTx;
    private recoverEvmToEvmTx;
    private signAndApproveGateway;
    /**
     * Check if given transaction is already executed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already executed
     */
    isExecuted(txHash: string): Promise<boolean>;
    /**
     * Check if given transaction is already confirmed.
     * @param txHash string - transaction hash
     * @returns Promise<boolean> - true if transaction is already confirmed
     */
    isConfirmed(txHash: string): Promise<boolean>;
    /**
     * Calculate the gas fee in native token for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateNativeGasFee(txHash: string, sourceChain: string, destinationChain: string, estimatedGasUsed: number, options: QueryGasFeeOptions): Promise<string>;
    /**
     * Calculate the gas fee in an ERC-20 tokens for executing a transaction at the destination chain using the source chain's gas price.
     * @param txHash string - transaction hash
     * @param sourceChain EVMChain - source chain
     * @param destinationChain EVMChain - destination chain
     * @param gasTokenSymbol string - gas token symbol
     * @param options QueryGasFeeOptions - options
     * @returns Promise<string> - The gas fee to be paid at source chain
     */
    calculateGasFee(txHash: string, sourceChain: EvmChain, destinationChain: EvmChain, estimatedGasUsed: number, options: QueryGasFeeOptions): Promise<string>;
    getEventIndex(chain: string, txHash: string, evmWalletDetails?: EvmWalletDetails): Promise<Nullable<number>>;
    addGasToCosmosChain({ gasLimit, autocalculateGasOptions, sendOptions, ...params }: AddGasParams): Promise<AddGasResponse>;
    /**
     * Pay native token as gas fee for the given transaction hash.
     * If the transaction details is not valid, it will return an error with reason.
     * @param chain - source chain
     * @param txHash - transaction hash
     * @param estimatedGasUsed - estimated gas used
     * @param options - options
     * @returns
     */
    addNativeGas(chain: EvmChain, txHash: string, estimatedGasUsed: number, options?: AddGasOptions): Promise<TxResult>;
    /**
     * Pay ERC20 token as gas fee for the given transaction hash.
     * If the transaction details or `gasTokenAddress` is not valid, it will return an error with reason.
     *
     * @param chain EvmChain - The source chain of the transaction hash.
     * @param txHash string - The transaction hash.
     * @param gasTokenAddress string - The address of the ERC20 token to pay as gas fee.
     * @param options AddGasOptions - The options to pay gas fee.
     * @returns
     */
    addGas(chain: EvmChain, txHash: string, gasTokenAddress: string, estimatedGasUsed: number, options?: AddGasOptions): Promise<TxResult>;
    /**
     * Execute a transaction on the destination chain associated with given `srcTxHash`.
     * @param srcTxHash - The transaction hash on the source chain.
     * @param srcTxLogIndex - The log index of the transaction on the source chain.
     * @param evmWalletDetails - The wallet details to use for executing the transaction.
     * @returns The result of executing the transaction.
     */
    execute(srcTxHash: string, srcTxLogIndex?: number, evmWalletDetails?: EvmWalletDetails): Promise<TxResult>;
    private subtractGasFee;
    private getSigner;
    getStaticInfo(): Promise<Record<string, any>>;
}
export {};
//# sourceMappingURL=AxelarGMPRecoveryAPI.d.ts.map