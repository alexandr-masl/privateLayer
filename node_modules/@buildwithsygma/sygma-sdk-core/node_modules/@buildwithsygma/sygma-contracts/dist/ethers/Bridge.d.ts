import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export declare namespace Bridge {
    type ProposalStruct = {
        originDomainID: BigNumberish;
        depositNonce: BigNumberish;
        resourceID: BytesLike;
        data: BytesLike;
    };
    type ProposalStructOutput = [number, BigNumber, string, string] & {
        originDomainID: number;
        depositNonce: BigNumber;
        resourceID: string;
        data: string;
    };
}
export interface BridgeInterface extends utils.Interface {
    contractName: "Bridge";
    functions: {
        "_MPCAddress()": FunctionFragment;
        "_accessControl()": FunctionFragment;
        "_depositCounts(uint8)": FunctionFragment;
        "_domainID()": FunctionFragment;
        "_feeHandler()": FunctionFragment;
        "_resourceIDToHandlerAddress(bytes32)": FunctionFragment;
        "isValidForwarder(address)": FunctionFragment;
        "paused()": FunctionFragment;
        "usedNonces(uint8,uint256)": FunctionFragment;
        "adminPauseTransfers()": FunctionFragment;
        "adminUnpauseTransfers()": FunctionFragment;
        "adminSetResource(address,bytes32,address,bytes)": FunctionFragment;
        "adminSetBurnable(address,address)": FunctionFragment;
        "adminSetDepositNonce(uint8,uint64)": FunctionFragment;
        "adminSetForwarder(address,bool)": FunctionFragment;
        "adminChangeAccessControl(address)": FunctionFragment;
        "adminChangeFeeHandler(address)": FunctionFragment;
        "adminWithdraw(address,bytes)": FunctionFragment;
        "deposit(uint8,bytes32,bytes,bytes)": FunctionFragment;
        "executeProposal((uint8,uint64,bytes32,bytes),bytes)": FunctionFragment;
        "executeProposals((uint8,uint64,bytes32,bytes)[],bytes)": FunctionFragment;
        "startKeygen()": FunctionFragment;
        "endKeygen(address)": FunctionFragment;
        "refreshKey(string)": FunctionFragment;
        "retry(string)": FunctionFragment;
        "isProposalExecuted(uint8,uint256)": FunctionFragment;
        "verify((uint8,uint64,bytes32,bytes)[],bytes)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "_MPCAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "_accessControl", values?: undefined): string;
    encodeFunctionData(functionFragment: "_depositCounts", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "_domainID", values?: undefined): string;
    encodeFunctionData(functionFragment: "_feeHandler", values?: undefined): string;
    encodeFunctionData(functionFragment: "_resourceIDToHandlerAddress", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "isValidForwarder", values: [string]): string;
    encodeFunctionData(functionFragment: "paused", values?: undefined): string;
    encodeFunctionData(functionFragment: "usedNonces", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "adminPauseTransfers", values?: undefined): string;
    encodeFunctionData(functionFragment: "adminUnpauseTransfers", values?: undefined): string;
    encodeFunctionData(functionFragment: "adminSetResource", values: [string, BytesLike, string, BytesLike]): string;
    encodeFunctionData(functionFragment: "adminSetBurnable", values: [string, string]): string;
    encodeFunctionData(functionFragment: "adminSetDepositNonce", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "adminSetForwarder", values: [string, boolean]): string;
    encodeFunctionData(functionFragment: "adminChangeAccessControl", values: [string]): string;
    encodeFunctionData(functionFragment: "adminChangeFeeHandler", values: [string]): string;
    encodeFunctionData(functionFragment: "adminWithdraw", values: [string, BytesLike]): string;
    encodeFunctionData(functionFragment: "deposit", values: [BigNumberish, BytesLike, BytesLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "executeProposal", values: [Bridge.ProposalStruct, BytesLike]): string;
    encodeFunctionData(functionFragment: "executeProposals", values: [Bridge.ProposalStruct[], BytesLike]): string;
    encodeFunctionData(functionFragment: "startKeygen", values?: undefined): string;
    encodeFunctionData(functionFragment: "endKeygen", values: [string]): string;
    encodeFunctionData(functionFragment: "refreshKey", values: [string]): string;
    encodeFunctionData(functionFragment: "retry", values: [string]): string;
    encodeFunctionData(functionFragment: "isProposalExecuted", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "verify", values: [Bridge.ProposalStruct[], BytesLike]): string;
    decodeFunctionResult(functionFragment: "_MPCAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_accessControl", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_depositCounts", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_domainID", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_feeHandler", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_resourceIDToHandlerAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isValidForwarder", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "usedNonces", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminPauseTransfers", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminUnpauseTransfers", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminSetResource", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminSetBurnable", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminSetDepositNonce", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminSetForwarder", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminChangeAccessControl", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminChangeFeeHandler", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminWithdraw", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeProposals", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "startKeygen", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "endKeygen", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "refreshKey", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "retry", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isProposalExecuted", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
    events: {
        "AccessControlChanged(address)": EventFragment;
        "Deposit(uint8,bytes32,uint64,address,bytes,bytes)": EventFragment;
        "EndKeygen()": EventFragment;
        "FailedHandlerExecution(bytes,uint8,uint64)": EventFragment;
        "FeeHandlerChanged(address)": EventFragment;
        "KeyRefresh(string)": EventFragment;
        "Paused(address)": EventFragment;
        "ProposalExecution(uint8,uint64,bytes32,bytes)": EventFragment;
        "Retry(string)": EventFragment;
        "StartKeygen()": EventFragment;
        "Unpaused(address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "AccessControlChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "EndKeygen"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FailedHandlerExecution"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeHandlerChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "KeyRefresh"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "ProposalExecution"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Retry"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "StartKeygen"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
}
export declare type AccessControlChangedEvent = TypedEvent<[
    string
], {
    newAccessControl: string;
}>;
export declare type AccessControlChangedEventFilter = TypedEventFilter<AccessControlChangedEvent>;
export declare type DepositEvent = TypedEvent<[
    number,
    string,
    BigNumber,
    string,
    string,
    string
], {
    destinationDomainID: number;
    resourceID: string;
    depositNonce: BigNumber;
    user: string;
    data: string;
    handlerResponse: string;
}>;
export declare type DepositEventFilter = TypedEventFilter<DepositEvent>;
export declare type EndKeygenEvent = TypedEvent<[], {}>;
export declare type EndKeygenEventFilter = TypedEventFilter<EndKeygenEvent>;
export declare type FailedHandlerExecutionEvent = TypedEvent<[
    string,
    number,
    BigNumber
], {
    lowLevelData: string;
    originDomainID: number;
    depositNonce: BigNumber;
}>;
export declare type FailedHandlerExecutionEventFilter = TypedEventFilter<FailedHandlerExecutionEvent>;
export declare type FeeHandlerChangedEvent = TypedEvent<[
    string
], {
    newFeeHandler: string;
}>;
export declare type FeeHandlerChangedEventFilter = TypedEventFilter<FeeHandlerChangedEvent>;
export declare type KeyRefreshEvent = TypedEvent<[string], {
    hash: string;
}>;
export declare type KeyRefreshEventFilter = TypedEventFilter<KeyRefreshEvent>;
export declare type PausedEvent = TypedEvent<[string], {
    account: string;
}>;
export declare type PausedEventFilter = TypedEventFilter<PausedEvent>;
export declare type ProposalExecutionEvent = TypedEvent<[
    number,
    BigNumber,
    string,
    string
], {
    originDomainID: number;
    depositNonce: BigNumber;
    dataHash: string;
    handlerResponse: string;
}>;
export declare type ProposalExecutionEventFilter = TypedEventFilter<ProposalExecutionEvent>;
export declare type RetryEvent = TypedEvent<[string], {
    txHash: string;
}>;
export declare type RetryEventFilter = TypedEventFilter<RetryEvent>;
export declare type StartKeygenEvent = TypedEvent<[], {}>;
export declare type StartKeygenEventFilter = TypedEventFilter<StartKeygenEvent>;
export declare type UnpausedEvent = TypedEvent<[string], {
    account: string;
}>;
export declare type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;
export interface Bridge extends BaseContract {
    contractName: "Bridge";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: BridgeInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        _MPCAddress(overrides?: CallOverrides): Promise<[string]>;
        _accessControl(overrides?: CallOverrides): Promise<[string]>;
        _depositCounts(arg0: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
        _domainID(overrides?: CallOverrides): Promise<[number]>;
        _feeHandler(overrides?: CallOverrides): Promise<[string]>;
        _resourceIDToHandlerAddress(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        isValidForwarder(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Returns true if the contract is paused, and false otherwise.
         */
        paused(overrides?: CallOverrides): Promise<[boolean]>;
        usedNonces(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
        /**
         * Pauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        adminPauseTransfers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Unpauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.MPC address has to be set before Bridge can be unpaused
         */
        adminUnpauseTransfers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets a new resource for handler contracts that use the IERCHandler interface, and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param handlerAddress Address of handler resource will be set for.
         * @param resourceID ResourceID to be used when making deposits.
         */
        adminSetResource(handlerAddress: string, resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets a resource as burnable for handler contracts that use the IERCHandler interface.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param handlerAddress Address of handler resource will be set for.
         * @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.
         */
        adminSetBurnable(handlerAddress: string, tokenAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets the nonce for the specific domainID.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param domainID Domain ID for increasing nonce.
         * @param nonce The nonce value to be set.
         */
        adminSetDepositNonce(domainID: BigNumberish, nonce: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Set a forwarder to be used.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param forwarder Forwarder address to be added.
         * @param valid Decision for the specific forwarder.
         */
        adminSetForwarder(forwarder: string, valid: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Changes access control contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newAccessControl Address {_accessControl} will be updated to.
         */
        adminChangeAccessControl(newAccessControl: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Changes deposit fee handler contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newFeeHandler Address {_feeHandler} will be updated to.
         */
        adminChangeFeeHandler(newFeeHandler: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Used to manually withdraw funds from ERC safes.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param data ABI-encoded withdrawal params relevant to the specified handler.
         * @param handlerAddress Address of handler to withdraw from.
         */
        adminWithdraw(handlerAddress: string, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Initiates a transfer using a specified handler contract.Only callable when Bridge is not paused.Emits {Deposit} event with all necessary parameters and a handler response.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param resourceID ResourceID used to find address of handler to be used for deposit.
         */
        deposit(destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        executeProposal(proposal: Bridge.ProposalStruct, signature: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        executeProposals(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Once MPC address is set, this method can't be invoked anymore. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        startKeygen(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * This method can be called only once, after the MPC address is set Bridge is unpaused. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param MPCAddress Address that will be set as MPC address.
         */
        endKeygen(MPCAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * It's used to trigger the belonging process on the MPC side. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param hash Topology hash which prevents changes during refresh process.
         */
        refreshKey(hash: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * This method is used to trigger the process for retrying failed deposits on the MPC side.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.This is not applicable for failed executions on {PermissionedGenericHandler}
         * @param txHash Transaction hash which contains deposit that should be retried
         */
        retry(txHash: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Returns a boolean value.
         * @param depositNonce ID of deposit generated by origin Bridge contract.
         * @param domainID ID of chain deposit originated from.
         */
        isProposalExecuted(domainID: BigNumberish, depositNonce: BigNumberish, overrides?: CallOverrides): Promise<[boolean]>;
        verify(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;
    };
    _MPCAddress(overrides?: CallOverrides): Promise<string>;
    _accessControl(overrides?: CallOverrides): Promise<string>;
    _depositCounts(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    _domainID(overrides?: CallOverrides): Promise<number>;
    _feeHandler(overrides?: CallOverrides): Promise<string>;
    _resourceIDToHandlerAddress(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;
    isValidForwarder(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Returns true if the contract is paused, and false otherwise.
     */
    paused(overrides?: CallOverrides): Promise<boolean>;
    usedNonces(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * Pauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     */
    adminPauseTransfers(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Unpauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.MPC address has to be set before Bridge can be unpaused
     */
    adminUnpauseTransfers(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets a new resource for handler contracts that use the IERCHandler interface, and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param args Additional data to be passed to specified handler.
     * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
     * @param handlerAddress Address of handler resource will be set for.
     * @param resourceID ResourceID to be used when making deposits.
     */
    adminSetResource(handlerAddress: string, resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets a resource as burnable for handler contracts that use the IERCHandler interface.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param handlerAddress Address of handler resource will be set for.
     * @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.
     */
    adminSetBurnable(handlerAddress: string, tokenAddress: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets the nonce for the specific domainID.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param domainID Domain ID for increasing nonce.
     * @param nonce The nonce value to be set.
     */
    adminSetDepositNonce(domainID: BigNumberish, nonce: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Set a forwarder to be used.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param forwarder Forwarder address to be added.
     * @param valid Decision for the specific forwarder.
     */
    adminSetForwarder(forwarder: string, valid: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Changes access control contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param newAccessControl Address {_accessControl} will be updated to.
     */
    adminChangeAccessControl(newAccessControl: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Changes deposit fee handler contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param newFeeHandler Address {_feeHandler} will be updated to.
     */
    adminChangeFeeHandler(newFeeHandler: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Used to manually withdraw funds from ERC safes.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param data ABI-encoded withdrawal params relevant to the specified handler.
     * @param handlerAddress Address of handler to withdraw from.
     */
    adminWithdraw(handlerAddress: string, data: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Initiates a transfer using a specified handler contract.Only callable when Bridge is not paused.Emits {Deposit} event with all necessary parameters and a handler response.
     * @param depositData Additional data to be passed to specified handler.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param resourceID ResourceID used to find address of handler to be used for deposit.
     */
    deposit(destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    executeProposal(proposal: Bridge.ProposalStruct, signature: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    executeProposals(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Once MPC address is set, this method can't be invoked anymore. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     */
    startKeygen(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * This method can be called only once, after the MPC address is set Bridge is unpaused. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param MPCAddress Address that will be set as MPC address.
     */
    endKeygen(MPCAddress: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * It's used to trigger the belonging process on the MPC side. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
     * @param hash Topology hash which prevents changes during refresh process.
     */
    refreshKey(hash: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * This method is used to trigger the process for retrying failed deposits on the MPC side.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.This is not applicable for failed executions on {PermissionedGenericHandler}
     * @param txHash Transaction hash which contains deposit that should be retried
     */
    retry(txHash: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Returns a boolean value.
     * @param depositNonce ID of deposit generated by origin Bridge contract.
     * @param domainID ID of chain deposit originated from.
     */
    isProposalExecuted(domainID: BigNumberish, depositNonce: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
    verify(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    callStatic: {
        _MPCAddress(overrides?: CallOverrides): Promise<string>;
        _accessControl(overrides?: CallOverrides): Promise<string>;
        _depositCounts(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        _domainID(overrides?: CallOverrides): Promise<number>;
        _feeHandler(overrides?: CallOverrides): Promise<string>;
        _resourceIDToHandlerAddress(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;
        isValidForwarder(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Returns true if the contract is paused, and false otherwise.
         */
        paused(overrides?: CallOverrides): Promise<boolean>;
        usedNonces(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Pauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        adminPauseTransfers(overrides?: CallOverrides): Promise<void>;
        /**
         * Unpauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.MPC address has to be set before Bridge can be unpaused
         */
        adminUnpauseTransfers(overrides?: CallOverrides): Promise<void>;
        /**
         * Sets a new resource for handler contracts that use the IERCHandler interface, and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param handlerAddress Address of handler resource will be set for.
         * @param resourceID ResourceID to be used when making deposits.
         */
        adminSetResource(handlerAddress: string, resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * Sets a resource as burnable for handler contracts that use the IERCHandler interface.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param handlerAddress Address of handler resource will be set for.
         * @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.
         */
        adminSetBurnable(handlerAddress: string, tokenAddress: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Sets the nonce for the specific domainID.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param domainID Domain ID for increasing nonce.
         * @param nonce The nonce value to be set.
         */
        adminSetDepositNonce(domainID: BigNumberish, nonce: BigNumberish, overrides?: CallOverrides): Promise<void>;
        /**
         * Set a forwarder to be used.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param forwarder Forwarder address to be added.
         * @param valid Decision for the specific forwarder.
         */
        adminSetForwarder(forwarder: string, valid: boolean, overrides?: CallOverrides): Promise<void>;
        /**
         * Changes access control contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newAccessControl Address {_accessControl} will be updated to.
         */
        adminChangeAccessControl(newAccessControl: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Changes deposit fee handler contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newFeeHandler Address {_feeHandler} will be updated to.
         */
        adminChangeFeeHandler(newFeeHandler: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Used to manually withdraw funds from ERC safes.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param data ABI-encoded withdrawal params relevant to the specified handler.
         * @param handlerAddress Address of handler to withdraw from.
         */
        adminWithdraw(handlerAddress: string, data: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * Initiates a transfer using a specified handler contract.Only callable when Bridge is not paused.Emits {Deposit} event with all necessary parameters and a handler response.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param resourceID ResourceID used to find address of handler to be used for deposit.
         */
        deposit(destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[
            BigNumber,
            string
        ] & {
            depositNonce: BigNumber;
            handlerResponse: string;
        }>;
        executeProposal(proposal: Bridge.ProposalStruct, signature: BytesLike, overrides?: CallOverrides): Promise<void>;
        executeProposals(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * Once MPC address is set, this method can't be invoked anymore. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        startKeygen(overrides?: CallOverrides): Promise<void>;
        /**
         * This method can be called only once, after the MPC address is set Bridge is unpaused. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param MPCAddress Address that will be set as MPC address.
         */
        endKeygen(MPCAddress: string, overrides?: CallOverrides): Promise<void>;
        /**
         * It's used to trigger the belonging process on the MPC side. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param hash Topology hash which prevents changes during refresh process.
         */
        refreshKey(hash: string, overrides?: CallOverrides): Promise<void>;
        /**
         * This method is used to trigger the process for retrying failed deposits on the MPC side.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.This is not applicable for failed executions on {PermissionedGenericHandler}
         * @param txHash Transaction hash which contains deposit that should be retried
         */
        retry(txHash: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Returns a boolean value.
         * @param depositNonce ID of deposit generated by origin Bridge contract.
         * @param domainID ID of chain deposit originated from.
         */
        isProposalExecuted(domainID: BigNumberish, depositNonce: BigNumberish, overrides?: CallOverrides): Promise<boolean>;
        verify(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    };
    filters: {
        "AccessControlChanged(address)"(newAccessControl?: null): AccessControlChangedEventFilter;
        AccessControlChanged(newAccessControl?: null): AccessControlChangedEventFilter;
        "Deposit(uint8,bytes32,uint64,address,bytes,bytes)"(destinationDomainID?: null, resourceID?: null, depositNonce?: null, user?: string | null, data?: null, handlerResponse?: null): DepositEventFilter;
        Deposit(destinationDomainID?: null, resourceID?: null, depositNonce?: null, user?: string | null, data?: null, handlerResponse?: null): DepositEventFilter;
        "EndKeygen()"(): EndKeygenEventFilter;
        EndKeygen(): EndKeygenEventFilter;
        "FailedHandlerExecution(bytes,uint8,uint64)"(lowLevelData?: null, originDomainID?: null, depositNonce?: null): FailedHandlerExecutionEventFilter;
        FailedHandlerExecution(lowLevelData?: null, originDomainID?: null, depositNonce?: null): FailedHandlerExecutionEventFilter;
        "FeeHandlerChanged(address)"(newFeeHandler?: null): FeeHandlerChangedEventFilter;
        FeeHandlerChanged(newFeeHandler?: null): FeeHandlerChangedEventFilter;
        "KeyRefresh(string)"(hash?: null): KeyRefreshEventFilter;
        KeyRefresh(hash?: null): KeyRefreshEventFilter;
        "Paused(address)"(account?: null): PausedEventFilter;
        Paused(account?: null): PausedEventFilter;
        "ProposalExecution(uint8,uint64,bytes32,bytes)"(originDomainID?: null, depositNonce?: null, dataHash?: null, handlerResponse?: null): ProposalExecutionEventFilter;
        ProposalExecution(originDomainID?: null, depositNonce?: null, dataHash?: null, handlerResponse?: null): ProposalExecutionEventFilter;
        "Retry(string)"(txHash?: null): RetryEventFilter;
        Retry(txHash?: null): RetryEventFilter;
        "StartKeygen()"(): StartKeygenEventFilter;
        StartKeygen(): StartKeygenEventFilter;
        "Unpaused(address)"(account?: null): UnpausedEventFilter;
        Unpaused(account?: null): UnpausedEventFilter;
    };
    estimateGas: {
        _MPCAddress(overrides?: CallOverrides): Promise<BigNumber>;
        _accessControl(overrides?: CallOverrides): Promise<BigNumber>;
        _depositCounts(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        _domainID(overrides?: CallOverrides): Promise<BigNumber>;
        _feeHandler(overrides?: CallOverrides): Promise<BigNumber>;
        _resourceIDToHandlerAddress(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        isValidForwarder(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns true if the contract is paused, and false otherwise.
         */
        paused(overrides?: CallOverrides): Promise<BigNumber>;
        usedNonces(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Pauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        adminPauseTransfers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Unpauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.MPC address has to be set before Bridge can be unpaused
         */
        adminUnpauseTransfers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets a new resource for handler contracts that use the IERCHandler interface, and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param handlerAddress Address of handler resource will be set for.
         * @param resourceID ResourceID to be used when making deposits.
         */
        adminSetResource(handlerAddress: string, resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets a resource as burnable for handler contracts that use the IERCHandler interface.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param handlerAddress Address of handler resource will be set for.
         * @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.
         */
        adminSetBurnable(handlerAddress: string, tokenAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets the nonce for the specific domainID.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param domainID Domain ID for increasing nonce.
         * @param nonce The nonce value to be set.
         */
        adminSetDepositNonce(domainID: BigNumberish, nonce: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Set a forwarder to be used.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param forwarder Forwarder address to be added.
         * @param valid Decision for the specific forwarder.
         */
        adminSetForwarder(forwarder: string, valid: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Changes access control contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newAccessControl Address {_accessControl} will be updated to.
         */
        adminChangeAccessControl(newAccessControl: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Changes deposit fee handler contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newFeeHandler Address {_feeHandler} will be updated to.
         */
        adminChangeFeeHandler(newFeeHandler: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Used to manually withdraw funds from ERC safes.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param data ABI-encoded withdrawal params relevant to the specified handler.
         * @param handlerAddress Address of handler to withdraw from.
         */
        adminWithdraw(handlerAddress: string, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Initiates a transfer using a specified handler contract.Only callable when Bridge is not paused.Emits {Deposit} event with all necessary parameters and a handler response.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param resourceID ResourceID used to find address of handler to be used for deposit.
         */
        deposit(destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        executeProposal(proposal: Bridge.ProposalStruct, signature: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        executeProposals(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Once MPC address is set, this method can't be invoked anymore. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        startKeygen(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * This method can be called only once, after the MPC address is set Bridge is unpaused. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param MPCAddress Address that will be set as MPC address.
         */
        endKeygen(MPCAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * It's used to trigger the belonging process on the MPC side. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param hash Topology hash which prevents changes during refresh process.
         */
        refreshKey(hash: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * This method is used to trigger the process for retrying failed deposits on the MPC side.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.This is not applicable for failed executions on {PermissionedGenericHandler}
         * @param txHash Transaction hash which contains deposit that should be retried
         */
        retry(txHash: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Returns a boolean value.
         * @param depositNonce ID of deposit generated by origin Bridge contract.
         * @param domainID ID of chain deposit originated from.
         */
        isProposalExecuted(domainID: BigNumberish, depositNonce: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        verify(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        _MPCAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _accessControl(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _depositCounts(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _domainID(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _feeHandler(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _resourceIDToHandlerAddress(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isValidForwarder(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns true if the contract is paused, and false otherwise.
         */
        paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        usedNonces(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Pauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        adminPauseTransfers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Unpauses deposits, proposal creation and voting, and deposit executions.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.MPC address has to be set before Bridge can be unpaused
         */
        adminUnpauseTransfers(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets a new resource for handler contracts that use the IERCHandler interface, and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param handlerAddress Address of handler resource will be set for.
         * @param resourceID ResourceID to be used when making deposits.
         */
        adminSetResource(handlerAddress: string, resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets a resource as burnable for handler contracts that use the IERCHandler interface.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param handlerAddress Address of handler resource will be set for.
         * @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.
         */
        adminSetBurnable(handlerAddress: string, tokenAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets the nonce for the specific domainID.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param domainID Domain ID for increasing nonce.
         * @param nonce The nonce value to be set.
         */
        adminSetDepositNonce(domainID: BigNumberish, nonce: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Set a forwarder to be used.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param forwarder Forwarder address to be added.
         * @param valid Decision for the specific forwarder.
         */
        adminSetForwarder(forwarder: string, valid: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Changes access control contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newAccessControl Address {_accessControl} will be updated to.
         */
        adminChangeAccessControl(newAccessControl: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Changes deposit fee handler contract address.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param newFeeHandler Address {_feeHandler} will be updated to.
         */
        adminChangeFeeHandler(newFeeHandler: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Used to manually withdraw funds from ERC safes.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param data ABI-encoded withdrawal params relevant to the specified handler.
         * @param handlerAddress Address of handler to withdraw from.
         */
        adminWithdraw(handlerAddress: string, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Initiates a transfer using a specified handler contract.Only callable when Bridge is not paused.Emits {Deposit} event with all necessary parameters and a handler response.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param resourceID ResourceID used to find address of handler to be used for deposit.
         */
        deposit(destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        executeProposal(proposal: Bridge.ProposalStruct, signature: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        executeProposals(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Once MPC address is set, this method can't be invoked anymore. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         */
        startKeygen(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * This method can be called only once, after the MPC address is set Bridge is unpaused. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param MPCAddress Address that will be set as MPC address.
         */
        endKeygen(MPCAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * It's used to trigger the belonging process on the MPC side. It's used to trigger the belonging process on the MPC side which also handles keygen function calls order.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.
         * @param hash Topology hash which prevents changes during refresh process.
         */
        refreshKey(hash: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * This method is used to trigger the process for retrying failed deposits on the MPC side.Only callable by address that has the right to call the specific function, which is mapped in {functionAccess} in AccessControlSegregator contract.This is not applicable for failed executions on {PermissionedGenericHandler}
         * @param txHash Transaction hash which contains deposit that should be retried
         */
        retry(txHash: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Returns a boolean value.
         * @param depositNonce ID of deposit generated by origin Bridge contract.
         * @param domainID ID of chain deposit originated from.
         */
        isProposalExecuted(domainID: BigNumberish, depositNonce: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        verify(proposals: Bridge.ProposalStruct[], signature: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
