import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface DynamicFeeHandlerInterface extends utils.Interface {
    contractName: "DynamicFeeHandler";
    functions: {
        "DEFAULT_ADMIN_ROLE()": FunctionFragment;
        "_bridgeAddress()": FunctionFragment;
        "_feeHandlerRouterAddress()": FunctionFragment;
        "_feePercent()": FunctionFragment;
        "_gasUsed()": FunctionFragment;
        "_oracleAddress()": FunctionFragment;
        "getRoleAdmin(bytes32)": FunctionFragment;
        "grantRole(bytes32,address)": FunctionFragment;
        "hasRole(bytes32,address)": FunctionFragment;
        "renounceRole(bytes32,address)": FunctionFragment;
        "revokeRole(bytes32,address)": FunctionFragment;
        "supportsInterface(bytes4)": FunctionFragment;
        "renounceAdmin(address)": FunctionFragment;
        "setFeeOracle(address)": FunctionFragment;
        "setFeeProperties(uint32,uint16)": FunctionFragment;
        "collectFee(address,uint8,uint8,bytes32,bytes,bytes)": FunctionFragment;
        "calculateFee(address,uint8,uint8,bytes32,bytes,bytes)": FunctionFragment;
        "transferFee(bytes32,address[],uint256[])": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "DEFAULT_ADMIN_ROLE", values?: undefined): string;
    encodeFunctionData(functionFragment: "_bridgeAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "_feeHandlerRouterAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "_feePercent", values?: undefined): string;
    encodeFunctionData(functionFragment: "_gasUsed", values?: undefined): string;
    encodeFunctionData(functionFragment: "_oracleAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRoleAdmin", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "grantRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "hasRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "renounceRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "revokeRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "renounceAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "setFeeOracle", values: [string]): string;
    encodeFunctionData(functionFragment: "setFeeProperties", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "collectFee", values: [
        string,
        BigNumberish,
        BigNumberish,
        BytesLike,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "calculateFee", values: [
        string,
        BigNumberish,
        BigNumberish,
        BytesLike,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "transferFee", values: [BytesLike, string[], BigNumberish[]]): string;
    decodeFunctionResult(functionFragment: "DEFAULT_ADMIN_ROLE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_bridgeAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_feeHandlerRouterAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_feePercent", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_gasUsed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_oracleAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setFeeOracle", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setFeeProperties", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collectFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "calculateFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFee", data: BytesLike): Result;
    events: {
        "FeeCollected(address,uint8,uint8,bytes32,uint256,address)": EventFragment;
        "FeeDistributed(address,address,uint256)": EventFragment;
        "FeeOracleAddressSet(address)": EventFragment;
        "FeeOraclePropertiesSet(uint32,uint16)": EventFragment;
        "RoleAdminChanged(bytes32,bytes32,bytes32)": EventFragment;
        "RoleGranted(bytes32,address,address)": EventFragment;
        "RoleRevoked(bytes32,address,address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FeeCollected"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeDistributed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeOracleAddressSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeOraclePropertiesSet"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleAdminChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
}
export declare type FeeCollectedEvent = TypedEvent<[
    string,
    number,
    number,
    string,
    BigNumber,
    string
], {
    sender: string;
    fromDomainID: number;
    destinationDomainID: number;
    resourceID: string;
    fee: BigNumber;
    tokenAddress: string;
}>;
export declare type FeeCollectedEventFilter = TypedEventFilter<FeeCollectedEvent>;
export declare type FeeDistributedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], {
    tokenAddress: string;
    recipient: string;
    amount: BigNumber;
}>;
export declare type FeeDistributedEventFilter = TypedEventFilter<FeeDistributedEvent>;
export declare type FeeOracleAddressSetEvent = TypedEvent<[
    string
], {
    feeOracleAddress: string;
}>;
export declare type FeeOracleAddressSetEventFilter = TypedEventFilter<FeeOracleAddressSetEvent>;
export declare type FeeOraclePropertiesSetEvent = TypedEvent<[
    number,
    number
], {
    gasUsed: number;
    feePercent: number;
}>;
export declare type FeeOraclePropertiesSetEventFilter = TypedEventFilter<FeeOraclePropertiesSetEvent>;
export declare type RoleAdminChangedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    previousAdminRole: string;
    newAdminRole: string;
}>;
export declare type RoleAdminChangedEventFilter = TypedEventFilter<RoleAdminChangedEvent>;
export declare type RoleGrantedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    account: string;
    sender: string;
}>;
export declare type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;
export declare type RoleRevokedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    account: string;
    sender: string;
}>;
export declare type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;
export interface DynamicFeeHandler extends BaseContract {
    contractName: "DynamicFeeHandler";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: DynamicFeeHandlerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;
        _bridgeAddress(overrides?: CallOverrides): Promise<[string]>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<[string]>;
        _feePercent(overrides?: CallOverrides): Promise<[number]>;
        _gasUsed(overrides?: CallOverrides): Promise<[number]>;
        _oracleAddress(overrides?: CallOverrides): Promise<[string]>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * See {IERC165-supportsInterface}.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets the fee oracle address for signature verification.
         * @param oracleAddress Fee oracle address.
         */
        setFeeOracle(oracleAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets the fee properties.
         * @param feePercent Percent of deposited amount taken as a fee. fee = depositAmount * feePercent / 1e4
         * @param gasUsed Gas used for transfer.
         */
        setFeeProperties(gasUsed: BigNumberish, feePercent: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
            fee: BigNumber;
            tokenAddress: string;
        }>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferFee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
    _bridgeAddress(overrides?: CallOverrides): Promise<string>;
    _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<string>;
    _feePercent(overrides?: CallOverrides): Promise<number>;
    _gasUsed(overrides?: CallOverrides): Promise<number>;
    _oracleAddress(overrides?: CallOverrides): Promise<string>;
    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;
    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * See {IERC165-supportsInterface}.
     */
    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
     * @param newAdmin Address that admin role will be granted to.
     */
    renounceAdmin(newAdmin: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets the fee oracle address for signature verification.
     * @param oracleAddress Fee oracle address.
     */
    setFeeOracle(oracleAddress: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets the fee properties.
     * @param feePercent Percent of deposited amount taken as a fee. fee = depositAmount * feePercent / 1e4
     * @param gasUsed Gas used for transfer.
     */
    setFeeProperties(gasUsed: BigNumberish, feePercent: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Collects fee for deposit.
     * @param depositData Additional data about the deposit.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param fromDomainID ID of the source chain.
     * @param resourceID ResourceID to be used when making deposits.
     * @param sender Sender of the deposit.
     */
    collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Calculates fee for deposit.
     * @param depositData Additional data about the deposit.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param fromDomainID ID of the source chain.
     * @param resourceID ResourceID to be used when making deposits.
     * @param sender Sender of the deposit.
     */
    calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
        fee: BigNumber;
        tokenAddress: string;
    }>;
    /**
     * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
     * @param addrs Array of addresses to transfer {amounts} to.
     * @param amounts Array of amounts to transfer to {addrs}.
     * @param resourceID ResourceID of the token.
     */
    transferFee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
        _bridgeAddress(overrides?: CallOverrides): Promise<string>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<string>;
        _feePercent(overrides?: CallOverrides): Promise<number>;
        _gasUsed(overrides?: CallOverrides): Promise<number>;
        _oracleAddress(overrides?: CallOverrides): Promise<string>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * See {IERC165-supportsInterface}.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Sets the fee oracle address for signature verification.
         * @param oracleAddress Fee oracle address.
         */
        setFeeOracle(oracleAddress: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Sets the fee properties.
         * @param feePercent Percent of deposited amount taken as a fee. fee = depositAmount * feePercent / 1e4
         * @param gasUsed Gas used for transfer.
         */
        setFeeProperties(gasUsed: BigNumberish, feePercent: BigNumberish, overrides?: CallOverrides): Promise<void>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
            fee: BigNumber;
            tokenAddress: string;
        }>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferFee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "FeeCollected(address,uint8,uint8,bytes32,uint256,address)"(sender?: null, fromDomainID?: null, destinationDomainID?: null, resourceID?: null, fee?: null, tokenAddress?: null): FeeCollectedEventFilter;
        FeeCollected(sender?: null, fromDomainID?: null, destinationDomainID?: null, resourceID?: null, fee?: null, tokenAddress?: null): FeeCollectedEventFilter;
        "FeeDistributed(address,address,uint256)"(tokenAddress?: null, recipient?: null, amount?: null): FeeDistributedEventFilter;
        FeeDistributed(tokenAddress?: null, recipient?: null, amount?: null): FeeDistributedEventFilter;
        "FeeOracleAddressSet(address)"(feeOracleAddress?: null): FeeOracleAddressSetEventFilter;
        FeeOracleAddressSet(feeOracleAddress?: null): FeeOracleAddressSetEventFilter;
        "FeeOraclePropertiesSet(uint32,uint16)"(gasUsed?: null, feePercent?: null): FeeOraclePropertiesSetEventFilter;
        FeeOraclePropertiesSet(gasUsed?: null, feePercent?: null): FeeOraclePropertiesSetEventFilter;
        "RoleAdminChanged(bytes32,bytes32,bytes32)"(role?: BytesLike | null, previousAdminRole?: BytesLike | null, newAdminRole?: BytesLike | null): RoleAdminChangedEventFilter;
        RoleAdminChanged(role?: BytesLike | null, previousAdminRole?: BytesLike | null, newAdminRole?: BytesLike | null): RoleAdminChangedEventFilter;
        "RoleGranted(bytes32,address,address)"(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleGrantedEventFilter;
        RoleGranted(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleGrantedEventFilter;
        "RoleRevoked(bytes32,address,address)"(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleRevokedEventFilter;
        RoleRevoked(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleRevokedEventFilter;
    };
    estimateGas: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;
        _bridgeAddress(overrides?: CallOverrides): Promise<BigNumber>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<BigNumber>;
        _feePercent(overrides?: CallOverrides): Promise<BigNumber>;
        _gasUsed(overrides?: CallOverrides): Promise<BigNumber>;
        _oracleAddress(overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * See {IERC165-supportsInterface}.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets the fee oracle address for signature verification.
         * @param oracleAddress Fee oracle address.
         */
        setFeeOracle(oracleAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets the fee properties.
         * @param feePercent Percent of deposited amount taken as a fee. fee = depositAmount * feePercent / 1e4
         * @param gasUsed Gas used for transfer.
         */
        setFeeProperties(gasUsed: BigNumberish, feePercent: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferFee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _bridgeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _feePercent(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _gasUsed(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _oracleAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * See {IERC165-supportsInterface}.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets the fee oracle address for signature verification.
         * @param oracleAddress Fee oracle address.
         */
        setFeeOracle(oracleAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets the fee properties.
         * @param feePercent Percent of deposited amount taken as a fee. fee = depositAmount * feePercent / 1e4
         * @param gasUsed Gas used for transfer.
         */
        setFeeProperties(gasUsed: BigNumberish, feePercent: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferFee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
