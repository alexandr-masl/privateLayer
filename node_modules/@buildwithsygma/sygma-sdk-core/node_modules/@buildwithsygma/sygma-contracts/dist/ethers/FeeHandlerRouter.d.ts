import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface FeeHandlerRouterInterface extends utils.Interface {
    contractName: "FeeHandlerRouter";
    functions: {
        "DEFAULT_ADMIN_ROLE()": FunctionFragment;
        "_bridgeAddress()": FunctionFragment;
        "_domainResourceIDToFeeHandlerAddress(uint8,bytes32)": FunctionFragment;
        "_whitelist(address)": FunctionFragment;
        "getRoleAdmin(bytes32)": FunctionFragment;
        "getRoleMember(bytes32,uint256)": FunctionFragment;
        "getRoleMemberCount(bytes32)": FunctionFragment;
        "getRoleMemberIndex(bytes32,address)": FunctionFragment;
        "grantRole(bytes32,address)": FunctionFragment;
        "hasRole(bytes32,address)": FunctionFragment;
        "renounceRole(bytes32,address)": FunctionFragment;
        "revokeRole(bytes32,address)": FunctionFragment;
        "adminSetResourceHandler(uint8,bytes32,address)": FunctionFragment;
        "adminSetWhitelist(address,bool)": FunctionFragment;
        "collectFee(address,uint8,uint8,bytes32,bytes,bytes)": FunctionFragment;
        "calculateFee(address,uint8,uint8,bytes32,bytes,bytes)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "DEFAULT_ADMIN_ROLE", values?: undefined): string;
    encodeFunctionData(functionFragment: "_bridgeAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "_domainResourceIDToFeeHandlerAddress", values: [BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "_whitelist", values: [string]): string;
    encodeFunctionData(functionFragment: "getRoleAdmin", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "getRoleMember", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getRoleMemberCount", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "getRoleMemberIndex", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "grantRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "hasRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "renounceRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "revokeRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "adminSetResourceHandler", values: [BigNumberish, BytesLike, string]): string;
    encodeFunctionData(functionFragment: "adminSetWhitelist", values: [string, boolean]): string;
    encodeFunctionData(functionFragment: "collectFee", values: [
        string,
        BigNumberish,
        BigNumberish,
        BytesLike,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "calculateFee", values: [
        string,
        BigNumberish,
        BigNumberish,
        BytesLike,
        BytesLike,
        BytesLike
    ]): string;
    decodeFunctionResult(functionFragment: "DEFAULT_ADMIN_ROLE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_bridgeAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_domainResourceIDToFeeHandlerAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_whitelist", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMember", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMemberCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMemberIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminSetResourceHandler", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "adminSetWhitelist", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collectFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "calculateFee", data: BytesLike): Result;
    events: {
        "FeeCollected(address,uint8,uint8,bytes32,uint256,address)": EventFragment;
        "FeeDistributed(address,address,uint256)": EventFragment;
        "RoleGranted(bytes32,address,address)": EventFragment;
        "RoleRevoked(bytes32,address,address)": EventFragment;
        "WhitelistChanged(address,bool)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FeeCollected"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeDistributed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "WhitelistChanged"): EventFragment;
}
export declare type FeeCollectedEvent = TypedEvent<[
    string,
    number,
    number,
    string,
    BigNumber,
    string
], {
    sender: string;
    fromDomainID: number;
    destinationDomainID: number;
    resourceID: string;
    fee: BigNumber;
    tokenAddress: string;
}>;
export declare type FeeCollectedEventFilter = TypedEventFilter<FeeCollectedEvent>;
export declare type FeeDistributedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], {
    tokenAddress: string;
    recipient: string;
    amount: BigNumber;
}>;
export declare type FeeDistributedEventFilter = TypedEventFilter<FeeDistributedEvent>;
export declare type RoleGrantedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    account: string;
    sender: string;
}>;
export declare type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;
export declare type RoleRevokedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    account: string;
    sender: string;
}>;
export declare type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;
export declare type WhitelistChangedEvent = TypedEvent<[
    string,
    boolean
], {
    whitelistAddress: string;
    isWhitelisted: boolean;
}>;
export declare type WhitelistChangedEventFilter = TypedEventFilter<WhitelistChangedEvent>;
export interface FeeHandlerRouter extends BaseContract {
    contractName: "FeeHandlerRouter";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: FeeHandlerRouterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;
        _bridgeAddress(overrides?: CallOverrides): Promise<[string]>;
        _domainResourceIDToFeeHandlerAddress(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        _whitelist(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Maps the {handlerAddress} to {resourceID} to {destinantionDomainID} in {_domainResourceIDToFeeHandlerAddress}.
         * @param destinationDomainID ID of chain FeeHandler contracts will be called.
         * @param handlerAddress Address of FeeHandler which will be called for specified resourceID.
         * @param resourceID ResourceID for which the corresponding FeeHandler will collect/calcualte fee.
         */
        adminSetResourceHandler(destinationDomainID: BigNumberish, resourceID: BytesLike, handlerAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets or revokes fee whitelist from an address.
         * @param isWhitelisted Set to true to exempt an address from paying fees.
         * @param whitelistAddress Address to be whitelisted.
         */
        adminSetWhitelist(whitelistAddress: string, isWhitelisted: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Initiates collecting fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Initiates calculating fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
            fee: BigNumber;
            tokenAddress: string;
        }>;
    };
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
    _bridgeAddress(overrides?: CallOverrides): Promise<string>;
    _domainResourceIDToFeeHandlerAddress(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<string>;
    _whitelist(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;
    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<string>;
    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * Returns the index of the account that have `role`.
     */
    getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Maps the {handlerAddress} to {resourceID} to {destinantionDomainID} in {_domainResourceIDToFeeHandlerAddress}.
     * @param destinationDomainID ID of chain FeeHandler contracts will be called.
     * @param handlerAddress Address of FeeHandler which will be called for specified resourceID.
     * @param resourceID ResourceID for which the corresponding FeeHandler will collect/calcualte fee.
     */
    adminSetResourceHandler(destinationDomainID: BigNumberish, resourceID: BytesLike, handlerAddress: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets or revokes fee whitelist from an address.
     * @param isWhitelisted Set to true to exempt an address from paying fees.
     * @param whitelistAddress Address to be whitelisted.
     */
    adminSetWhitelist(whitelistAddress: string, isWhitelisted: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Initiates collecting fee with corresponding fee handler contract using IFeeHandler interface.
     * @param depositData Additional data to be passed to specified handler.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param fromDomainID ID of the source chain.
     * @param resourceID ResourceID to be used when making deposits.
     * @param sender Sender of the deposit.
     */
    collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Initiates calculating fee with corresponding fee handler contract using IFeeHandler interface.
     * @param depositData Additional data to be passed to specified handler.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param fromDomainID ID of the source chain.
     * @param resourceID ResourceID to be used when making deposits.
     * @param sender Sender of the deposit.
     */
    calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
        fee: BigNumber;
        tokenAddress: string;
    }>;
    callStatic: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
        _bridgeAddress(overrides?: CallOverrides): Promise<string>;
        _domainResourceIDToFeeHandlerAddress(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<string>;
        _whitelist(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<string>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Maps the {handlerAddress} to {resourceID} to {destinantionDomainID} in {_domainResourceIDToFeeHandlerAddress}.
         * @param destinationDomainID ID of chain FeeHandler contracts will be called.
         * @param handlerAddress Address of FeeHandler which will be called for specified resourceID.
         * @param resourceID ResourceID for which the corresponding FeeHandler will collect/calcualte fee.
         */
        adminSetResourceHandler(destinationDomainID: BigNumberish, resourceID: BytesLike, handlerAddress: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Sets or revokes fee whitelist from an address.
         * @param isWhitelisted Set to true to exempt an address from paying fees.
         * @param whitelistAddress Address to be whitelisted.
         */
        adminSetWhitelist(whitelistAddress: string, isWhitelisted: boolean, overrides?: CallOverrides): Promise<void>;
        /**
         * Initiates collecting fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * Initiates calculating fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
            fee: BigNumber;
            tokenAddress: string;
        }>;
    };
    filters: {
        "FeeCollected(address,uint8,uint8,bytes32,uint256,address)"(sender?: null, fromDomainID?: null, destinationDomainID?: null, resourceID?: null, fee?: null, tokenAddress?: null): FeeCollectedEventFilter;
        FeeCollected(sender?: null, fromDomainID?: null, destinationDomainID?: null, resourceID?: null, fee?: null, tokenAddress?: null): FeeCollectedEventFilter;
        "FeeDistributed(address,address,uint256)"(tokenAddress?: null, recipient?: null, amount?: null): FeeDistributedEventFilter;
        FeeDistributed(tokenAddress?: null, recipient?: null, amount?: null): FeeDistributedEventFilter;
        "RoleGranted(bytes32,address,address)"(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleGrantedEventFilter;
        RoleGranted(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleGrantedEventFilter;
        "RoleRevoked(bytes32,address,address)"(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleRevokedEventFilter;
        RoleRevoked(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleRevokedEventFilter;
        "WhitelistChanged(address,bool)"(whitelistAddress?: null, isWhitelisted?: null): WhitelistChangedEventFilter;
        WhitelistChanged(whitelistAddress?: null, isWhitelisted?: null): WhitelistChangedEventFilter;
    };
    estimateGas: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;
        _bridgeAddress(overrides?: CallOverrides): Promise<BigNumber>;
        _domainResourceIDToFeeHandlerAddress(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        _whitelist(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Maps the {handlerAddress} to {resourceID} to {destinantionDomainID} in {_domainResourceIDToFeeHandlerAddress}.
         * @param destinationDomainID ID of chain FeeHandler contracts will be called.
         * @param handlerAddress Address of FeeHandler which will be called for specified resourceID.
         * @param resourceID ResourceID for which the corresponding FeeHandler will collect/calcualte fee.
         */
        adminSetResourceHandler(destinationDomainID: BigNumberish, resourceID: BytesLike, handlerAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets or revokes fee whitelist from an address.
         * @param isWhitelisted Set to true to exempt an address from paying fees.
         * @param whitelistAddress Address to be whitelisted.
         */
        adminSetWhitelist(whitelistAddress: string, isWhitelisted: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Initiates collecting fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Initiates calculating fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _bridgeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _domainResourceIDToFeeHandlerAddress(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _whitelist(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Maps the {handlerAddress} to {resourceID} to {destinantionDomainID} in {_domainResourceIDToFeeHandlerAddress}.
         * @param destinationDomainID ID of chain FeeHandler contracts will be called.
         * @param handlerAddress Address of FeeHandler which will be called for specified resourceID.
         * @param resourceID ResourceID for which the corresponding FeeHandler will collect/calcualte fee.
         */
        adminSetResourceHandler(destinationDomainID: BigNumberish, resourceID: BytesLike, handlerAddress: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets or revokes fee whitelist from an address.
         * @param isWhitelisted Set to true to exempt an address from paying fees.
         * @param whitelistAddress Address to be whitelisted.
         */
        adminSetWhitelist(whitelistAddress: string, isWhitelisted: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Initiates collecting fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Initiates calculating fee with corresponding fee handler contract using IFeeHandler interface.
         * @param depositData Additional data to be passed to specified handler.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
