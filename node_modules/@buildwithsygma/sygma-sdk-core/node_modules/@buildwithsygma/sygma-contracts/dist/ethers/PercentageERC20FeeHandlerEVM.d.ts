import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface PercentageERC20FeeHandlerEVMInterface extends utils.Interface {
    contractName: "PercentageERC20FeeHandlerEVM";
    functions: {
        "DEFAULT_ADMIN_ROLE()": FunctionFragment;
        "HUNDRED_PERCENT()": FunctionFragment;
        "_bridgeAddress()": FunctionFragment;
        "_domainResourceIDToFee(uint8,bytes32)": FunctionFragment;
        "_feeHandlerRouterAddress()": FunctionFragment;
        "_resourceIDToFeeBounds(bytes32)": FunctionFragment;
        "changeFee(uint8,bytes32,uint256)": FunctionFragment;
        "getRoleAdmin(bytes32)": FunctionFragment;
        "getRoleMember(bytes32,uint256)": FunctionFragment;
        "getRoleMemberCount(bytes32)": FunctionFragment;
        "getRoleMemberIndex(bytes32,address)": FunctionFragment;
        "grantRole(bytes32,address)": FunctionFragment;
        "hasRole(bytes32,address)": FunctionFragment;
        "renounceAdmin(address)": FunctionFragment;
        "renounceRole(bytes32,address)": FunctionFragment;
        "revokeRole(bytes32,address)": FunctionFragment;
        "transferFee(address[],uint256[])": FunctionFragment;
        "calculateFee(address,uint8,uint8,bytes32,bytes,bytes)": FunctionFragment;
        "collectFee(address,uint8,uint8,bytes32,bytes,bytes)": FunctionFragment;
        "changeFeeBounds(bytes32,uint128,uint128)": FunctionFragment;
        "transferERC20Fee(bytes32,address[],uint256[])": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "DEFAULT_ADMIN_ROLE", values?: undefined): string;
    encodeFunctionData(functionFragment: "HUNDRED_PERCENT", values?: undefined): string;
    encodeFunctionData(functionFragment: "_bridgeAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "_domainResourceIDToFee", values: [BigNumberish, BytesLike]): string;
    encodeFunctionData(functionFragment: "_feeHandlerRouterAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "_resourceIDToFeeBounds", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "changeFee", values: [BigNumberish, BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getRoleAdmin", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "getRoleMember", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "getRoleMemberCount", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "getRoleMemberIndex", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "grantRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "hasRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "renounceAdmin", values: [string]): string;
    encodeFunctionData(functionFragment: "renounceRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "revokeRole", values: [BytesLike, string]): string;
    encodeFunctionData(functionFragment: "transferFee", values: [string[], BigNumberish[]]): string;
    encodeFunctionData(functionFragment: "calculateFee", values: [
        string,
        BigNumberish,
        BigNumberish,
        BytesLike,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "collectFee", values: [
        string,
        BigNumberish,
        BigNumberish,
        BytesLike,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "changeFeeBounds", values: [BytesLike, BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "transferERC20Fee", values: [BytesLike, string[], BigNumberish[]]): string;
    decodeFunctionResult(functionFragment: "DEFAULT_ADMIN_ROLE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "HUNDRED_PERCENT", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_bridgeAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_domainResourceIDToFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_feeHandlerRouterAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_resourceIDToFeeBounds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "changeFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMember", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMemberCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoleMemberIndex", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceAdmin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "calculateFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collectFee", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "changeFeeBounds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferERC20Fee", data: BytesLike): Result;
    events: {
        "FeeBoundsChanged(uint256,uint256)": EventFragment;
        "FeeChanged(uint256)": EventFragment;
        "FeeCollected(address,uint8,uint8,bytes32,uint256,address)": EventFragment;
        "FeeDistributed(address,address,uint256)": EventFragment;
        "RoleGranted(bytes32,address,address)": EventFragment;
        "RoleRevoked(bytes32,address,address)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "FeeBoundsChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeChanged"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeCollected"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "FeeDistributed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
}
export declare type FeeBoundsChangedEvent = TypedEvent<[
    BigNumber,
    BigNumber
], {
    newLowerBound: BigNumber;
    newUpperBound: BigNumber;
}>;
export declare type FeeBoundsChangedEventFilter = TypedEventFilter<FeeBoundsChangedEvent>;
export declare type FeeChangedEvent = TypedEvent<[BigNumber], {
    newFee: BigNumber;
}>;
export declare type FeeChangedEventFilter = TypedEventFilter<FeeChangedEvent>;
export declare type FeeCollectedEvent = TypedEvent<[
    string,
    number,
    number,
    string,
    BigNumber,
    string
], {
    sender: string;
    fromDomainID: number;
    destinationDomainID: number;
    resourceID: string;
    fee: BigNumber;
    tokenAddress: string;
}>;
export declare type FeeCollectedEventFilter = TypedEventFilter<FeeCollectedEvent>;
export declare type FeeDistributedEvent = TypedEvent<[
    string,
    string,
    BigNumber
], {
    tokenAddress: string;
    recipient: string;
    amount: BigNumber;
}>;
export declare type FeeDistributedEventFilter = TypedEventFilter<FeeDistributedEvent>;
export declare type RoleGrantedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    account: string;
    sender: string;
}>;
export declare type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;
export declare type RoleRevokedEvent = TypedEvent<[
    string,
    string,
    string
], {
    role: string;
    account: string;
    sender: string;
}>;
export declare type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;
export interface PercentageERC20FeeHandlerEVM extends BaseContract {
    contractName: "PercentageERC20FeeHandlerEVM";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: PercentageERC20FeeHandlerEVMInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;
        HUNDRED_PERCENT(overrides?: CallOverrides): Promise<[number]>;
        _bridgeAddress(overrides?: CallOverrides): Promise<[string]>;
        _domainResourceIDToFee(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<[string]>;
        _resourceIDToFeeBounds(arg0: BytesLike, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            lowerBound: BigNumber;
            upperBound: BigNumber;
        }>;
        /**
         * Maps the {newFee} to {destinantionDomainID} to {resourceID} in {_domainResourceIDToFee}.Only callable by admin.
         * @param destinationDomainID ID of chain fee will be set.
         * @param newFee Value to which fee will be updated to for the provided {destinantionDomainID} and {resourceID}.
         * @param resourceID ResourceID for which fee will be set.
         */
        changeFee(destinationDomainID: BigNumberish, resourceID: BytesLike, newFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Transfers eth in the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount (in WEI) from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         */
        transferFee(addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
            fee: BigNumber;
            tokenAddress: string;
        }>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Sets new value for lower and upper fee bounds, both are in token amount.Only callable by admin.
         * @param newLowerBound Value {_newLowerBound} will be updated to.
         * @param newUpperBound Value {_newUpperBound} will be updated to.
         * @param resourceID ResourceID for which new fee bounds will be set.
         */
        changeFeeBounds(resourceID: BytesLike, newLowerBound: BigNumberish, newUpperBound: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferERC20Fee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
    HUNDRED_PERCENT(overrides?: CallOverrides): Promise<number>;
    _bridgeAddress(overrides?: CallOverrides): Promise<string>;
    _domainResourceIDToFee(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
    _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<string>;
    _resourceIDToFeeBounds(arg0: BytesLike, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber
    ] & {
        lowerBound: BigNumber;
        upperBound: BigNumber;
    }>;
    /**
     * Maps the {newFee} to {destinantionDomainID} to {resourceID} in {_domainResourceIDToFee}.Only callable by admin.
     * @param destinationDomainID ID of chain fee will be set.
     * @param newFee Value to which fee will be updated to for the provided {destinantionDomainID} and {resourceID}.
     * @param resourceID ResourceID for which fee will be set.
     */
    changeFee(destinationDomainID: BigNumberish, resourceID: BytesLike, newFee: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
     */
    getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;
    /**
     * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
     */
    getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<string>;
    /**
     * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
     */
    getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * Returns the index of the account that have `role`.
     */
    getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
    /**
     * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
     */
    grantRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Returns `true` if `account` has been granted `role`.
     */
    hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
     * @param newAdmin Address that admin role will be granted to.
     */
    renounceAdmin(newAdmin: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
     */
    renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
     */
    revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Transfers eth in the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount (in WEI) from amounts at index 0.
     * @param addrs Array of addresses to transfer {amounts} to.
     * @param amounts Array of amounts to transfer to {addrs}.
     */
    transferFee(addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Calculates fee for deposit.
     * @param depositData Additional data about the deposit.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param fromDomainID ID of the source chain.
     * @param resourceID ResourceID to be used when making deposits.
     * @param sender Sender of the deposit.
     */
    calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
        fee: BigNumber;
        tokenAddress: string;
    }>;
    /**
     * Collects fee for deposit.
     * @param depositData Additional data about the deposit.
     * @param destinationDomainID ID of chain deposit will be bridged to.
     * @param feeData Additional data to be passed to the fee handler.
     * @param fromDomainID ID of the source chain.
     * @param resourceID ResourceID to be used when making deposits.
     * @param sender Sender of the deposit.
     */
    collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Sets new value for lower and upper fee bounds, both are in token amount.Only callable by admin.
     * @param newLowerBound Value {_newLowerBound} will be updated to.
     * @param newUpperBound Value {_newUpperBound} will be updated to.
     * @param resourceID ResourceID for which new fee bounds will be set.
     */
    changeFeeBounds(resourceID: BytesLike, newLowerBound: BigNumberish, newUpperBound: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
     * @param addrs Array of addresses to transfer {amounts} to.
     * @param amounts Array of amounts to transfer to {addrs}.
     * @param resourceID ResourceID of the token.
     */
    transferERC20Fee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;
        HUNDRED_PERCENT(overrides?: CallOverrides): Promise<number>;
        _bridgeAddress(overrides?: CallOverrides): Promise<string>;
        _domainResourceIDToFee(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<string>;
        _resourceIDToFeeBounds(arg0: BytesLike, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber
        ] & {
            lowerBound: BigNumber;
            upperBound: BigNumber;
        }>;
        /**
         * Maps the {newFee} to {destinantionDomainID} to {resourceID} in {_domainResourceIDToFee}.Only callable by admin.
         * @param destinationDomainID ID of chain fee will be set.
         * @param newFee Value to which fee will be updated to for the provided {destinantionDomainID} and {resourceID}.
         * @param resourceID ResourceID for which fee will be set.
         */
        changeFee(destinationDomainID: BigNumberish, resourceID: BytesLike, newFee: BigNumberish, overrides?: CallOverrides): Promise<void>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<string>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<string>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<void>;
        /**
         * Transfers eth in the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount (in WEI) from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         */
        transferFee(addrs: string[], amounts: BigNumberish[], overrides?: CallOverrides): Promise<void>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<[BigNumber, string] & {
            fee: BigNumber;
            tokenAddress: string;
        }>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * Sets new value for lower and upper fee bounds, both are in token amount.Only callable by admin.
         * @param newLowerBound Value {_newLowerBound} will be updated to.
         * @param newUpperBound Value {_newUpperBound} will be updated to.
         * @param resourceID ResourceID for which new fee bounds will be set.
         */
        changeFeeBounds(resourceID: BytesLike, newLowerBound: BigNumberish, newUpperBound: BigNumberish, overrides?: CallOverrides): Promise<void>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferERC20Fee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "FeeBoundsChanged(uint256,uint256)"(newLowerBound?: null, newUpperBound?: null): FeeBoundsChangedEventFilter;
        FeeBoundsChanged(newLowerBound?: null, newUpperBound?: null): FeeBoundsChangedEventFilter;
        "FeeChanged(uint256)"(newFee?: null): FeeChangedEventFilter;
        FeeChanged(newFee?: null): FeeChangedEventFilter;
        "FeeCollected(address,uint8,uint8,bytes32,uint256,address)"(sender?: null, fromDomainID?: null, destinationDomainID?: null, resourceID?: null, fee?: null, tokenAddress?: null): FeeCollectedEventFilter;
        FeeCollected(sender?: null, fromDomainID?: null, destinationDomainID?: null, resourceID?: null, fee?: null, tokenAddress?: null): FeeCollectedEventFilter;
        "FeeDistributed(address,address,uint256)"(tokenAddress?: null, recipient?: null, amount?: null): FeeDistributedEventFilter;
        FeeDistributed(tokenAddress?: null, recipient?: null, amount?: null): FeeDistributedEventFilter;
        "RoleGranted(bytes32,address,address)"(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleGrantedEventFilter;
        RoleGranted(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleGrantedEventFilter;
        "RoleRevoked(bytes32,address,address)"(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleRevokedEventFilter;
        RoleRevoked(role?: BytesLike | null, account?: string | null, sender?: string | null): RoleRevokedEventFilter;
    };
    estimateGas: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;
        HUNDRED_PERCENT(overrides?: CallOverrides): Promise<BigNumber>;
        _bridgeAddress(overrides?: CallOverrides): Promise<BigNumber>;
        _domainResourceIDToFee(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<BigNumber>;
        _resourceIDToFeeBounds(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Maps the {newFee} to {destinantionDomainID} to {resourceID} in {_domainResourceIDToFee}.Only callable by admin.
         * @param destinationDomainID ID of chain fee will be set.
         * @param newFee Value to which fee will be updated to for the provided {destinantionDomainID} and {resourceID}.
         * @param resourceID ResourceID for which fee will be set.
         */
        changeFee(destinationDomainID: BigNumberish, resourceID: BytesLike, newFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Transfers eth in the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount (in WEI) from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         */
        transferFee(addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Sets new value for lower and upper fee bounds, both are in token amount.Only callable by admin.
         * @param newLowerBound Value {_newLowerBound} will be updated to.
         * @param newUpperBound Value {_newUpperBound} will be updated to.
         * @param resourceID ResourceID for which new fee bounds will be set.
         */
        changeFeeBounds(resourceID: BytesLike, newLowerBound: BigNumberish, newUpperBound: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferERC20Fee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        HUNDRED_PERCENT(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _bridgeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _domainResourceIDToFee(arg0: BigNumberish, arg1: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _feeHandlerRouterAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _resourceIDToFeeBounds(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Maps the {newFee} to {destinantionDomainID} to {resourceID} in {_domainResourceIDToFee}.Only callable by admin.
         * @param destinationDomainID ID of chain fee will be set.
         * @param newFee Value to which fee will be updated to for the provided {destinantionDomainID} and {resourceID}.
         * @param resourceID ResourceID for which fee will be set.
         */
        changeFee(destinationDomainID: BigNumberish, resourceID: BytesLike, newFee: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.
         */
        getRoleAdmin(role: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns one of the accounts that have `role`. `index` must be a value between 0 and {getRoleMemberCount}, non-inclusive. Role bearers are not sorted in any particular way, and their ordering may change at any point. WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure you perform all queries on the same block. See the following https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] for more information.
         */
        getRoleMember(role: BytesLike, index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns the number of accounts that have `role`. Can be used together with {getRoleMember} to enumerate all bearers of a role.
         */
        getRoleMemberCount(role: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Returns the index of the account that have `role`.
         */
        getRoleMemberIndex(role: BytesLike, account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.
         */
        grantRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Returns `true` if `account` has been granted `role`.
         */
        hasRole(role: BytesLike, account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Removes admin role from {_msgSender()} and grants it to {newAdmin}.Only callable by an address that currently has the admin role.
         * @param newAdmin Address that admin role will be granted to.
         */
        renounceAdmin(newAdmin: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`.
         */
        renounceRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.
         */
        revokeRole(role: BytesLike, account: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Transfers eth in the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount (in WEI) from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         */
        transferFee(addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Calculates fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        calculateFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Collects fee for deposit.
         * @param depositData Additional data about the deposit.
         * @param destinationDomainID ID of chain deposit will be bridged to.
         * @param feeData Additional data to be passed to the fee handler.
         * @param fromDomainID ID of the source chain.
         * @param resourceID ResourceID to be used when making deposits.
         * @param sender Sender of the deposit.
         */
        collectFee(sender: string, fromDomainID: BigNumberish, destinationDomainID: BigNumberish, resourceID: BytesLike, depositData: BytesLike, feeData: BytesLike, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Sets new value for lower and upper fee bounds, both are in token amount.Only callable by admin.
         * @param newLowerBound Value {_newLowerBound} will be updated to.
         * @param newUpperBound Value {_newUpperBound} will be updated to.
         * @param resourceID ResourceID for which new fee bounds will be set.
         */
        changeFeeBounds(resourceID: BytesLike, newLowerBound: BigNumberish, newUpperBound: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * Transfers tokens from the contract to the specified addresses. The parameters addrs and amounts are mapped 1-1. This means that the address at index 0 for addrs will receive the amount of tokens from amounts at index 0.
         * @param addrs Array of addresses to transfer {amounts} to.
         * @param amounts Array of amounts to transfer to {addrs}.
         * @param resourceID ResourceID of the token.
         */
        transferERC20Fee(resourceID: BytesLike, addrs: string[], amounts: BigNumberish[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
