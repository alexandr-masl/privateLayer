import { BaseContract, BigNumber, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface PermissionlessGenericHandlerInterface extends utils.Interface {
    contractName: "PermissionlessGenericHandler";
    functions: {
        "MAX_FEE()": FunctionFragment;
        "_bridgeAddress()": FunctionFragment;
        "setResource(bytes32,address,bytes)": FunctionFragment;
        "deposit(bytes32,address,bytes)": FunctionFragment;
        "executeProposal(bytes32,bytes)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "MAX_FEE", values?: undefined): string;
    encodeFunctionData(functionFragment: "_bridgeAddress", values?: undefined): string;
    encodeFunctionData(functionFragment: "setResource", values: [BytesLike, string, BytesLike]): string;
    encodeFunctionData(functionFragment: "deposit", values: [BytesLike, string, BytesLike]): string;
    encodeFunctionData(functionFragment: "executeProposal", values: [BytesLike, BytesLike]): string;
    decodeFunctionResult(functionFragment: "MAX_FEE", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "_bridgeAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setResource", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeProposal", data: BytesLike): Result;
    events: {};
}
export interface PermissionlessGenericHandler extends BaseContract {
    contractName: "PermissionlessGenericHandler";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: PermissionlessGenericHandlerInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        MAX_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;
        _bridgeAddress(overrides?: CallOverrides): Promise<[string]>;
        /**
         * Blank function, required in IHandler.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param resourceID ResourceID to be used when making deposits.
         */
        setResource(resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        /**
         * A deposit is initiated by making a deposit in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                       uint256  bytes  0                                                                                           -  32 len(executeFuncSignature):    uint16   bytes  32                                                                                          -  34 executeFuncSignature:         bytes    bytes  34                                                                                          -  34 + len(executeFuncSignature) len(executeContractAddress):  uint8    bytes  34 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) executeContractAddress        bytes    bytes  35 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):  uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:       bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param depositor Address of the account making deposit in the Bridge contract.
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        deposit(resourceID: BytesLike, depositor: string, data: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        /**
         * Proposal execution should be initiated when a proposal is finalized in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                             uint256  bytes  0                                                             -  32 len(executeFuncSignature):          uint16   bytes  32                                                            -  34 executeFuncSignature:               bytes    bytes  34                                                            -  34 + len(executeFuncSignature) len(executeContractAddress):        uint8    bytes  34 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) executeContractAddress              bytes    bytes  35 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):        uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)  -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:             bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                      bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        executeProposal(resourceID: BytesLike, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    MAX_FEE(overrides?: CallOverrides): Promise<BigNumber>;
    _bridgeAddress(overrides?: CallOverrides): Promise<string>;
    /**
     * Blank function, required in IHandler.
     * @param args Additional data to be passed to specified handler.
     * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
     * @param resourceID ResourceID to be used when making deposits.
     */
    setResource(resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    /**
     * A deposit is initiated by making a deposit in the Bridge contract.
     * @param data Structure should be constructed as follows: maxFee:                       uint256  bytes  0                                                                                           -  32 len(executeFuncSignature):    uint16   bytes  32                                                                                          -  34 executeFuncSignature:         bytes    bytes  34                                                                                          -  34 + len(executeFuncSignature) len(executeContractAddress):  uint8    bytes  34 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) executeContractAddress        bytes    bytes  35 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):  uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:       bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
     * @param depositor Address of the account making deposit in the Bridge contract.
     * @param resourceID ResourceID used to find address of contract to be used for deposit.
     */
    deposit(resourceID: BytesLike, depositor: string, data: BytesLike, overrides?: CallOverrides): Promise<string>;
    /**
     * Proposal execution should be initiated when a proposal is finalized in the Bridge contract.
     * @param data Structure should be constructed as follows: maxFee:                             uint256  bytes  0                                                             -  32 len(executeFuncSignature):          uint16   bytes  32                                                            -  34 executeFuncSignature:               bytes    bytes  34                                                            -  34 + len(executeFuncSignature) len(executeContractAddress):        uint8    bytes  34 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) executeContractAddress              bytes    bytes  35 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):        uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)  -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:             bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                      bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
     * @param resourceID ResourceID used to find address of contract to be used for deposit.
     */
    executeProposal(resourceID: BytesLike, data: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        MAX_FEE(overrides?: CallOverrides): Promise<BigNumber>;
        _bridgeAddress(overrides?: CallOverrides): Promise<string>;
        /**
         * Blank function, required in IHandler.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param resourceID ResourceID to be used when making deposits.
         */
        setResource(resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: CallOverrides): Promise<void>;
        /**
         * A deposit is initiated by making a deposit in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                       uint256  bytes  0                                                                                           -  32 len(executeFuncSignature):    uint16   bytes  32                                                                                          -  34 executeFuncSignature:         bytes    bytes  34                                                                                          -  34 + len(executeFuncSignature) len(executeContractAddress):  uint8    bytes  34 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) executeContractAddress        bytes    bytes  35 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):  uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:       bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param depositor Address of the account making deposit in the Bridge contract.
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        deposit(resourceID: BytesLike, depositor: string, data: BytesLike, overrides?: CallOverrides): Promise<string>;
        /**
         * Proposal execution should be initiated when a proposal is finalized in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                             uint256  bytes  0                                                             -  32 len(executeFuncSignature):          uint16   bytes  32                                                            -  34 executeFuncSignature:               bytes    bytes  34                                                            -  34 + len(executeFuncSignature) len(executeContractAddress):        uint8    bytes  34 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) executeContractAddress              bytes    bytes  35 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):        uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)  -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:             bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                      bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        executeProposal(resourceID: BytesLike, data: BytesLike, overrides?: CallOverrides): Promise<string>;
    };
    filters: {};
    estimateGas: {
        MAX_FEE(overrides?: CallOverrides): Promise<BigNumber>;
        _bridgeAddress(overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Blank function, required in IHandler.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param resourceID ResourceID to be used when making deposits.
         */
        setResource(resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        /**
         * A deposit is initiated by making a deposit in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                       uint256  bytes  0                                                                                           -  32 len(executeFuncSignature):    uint16   bytes  32                                                                                          -  34 executeFuncSignature:         bytes    bytes  34                                                                                          -  34 + len(executeFuncSignature) len(executeContractAddress):  uint8    bytes  34 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) executeContractAddress        bytes    bytes  35 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):  uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:       bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param depositor Address of the account making deposit in the Bridge contract.
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        deposit(resourceID: BytesLike, depositor: string, data: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Proposal execution should be initiated when a proposal is finalized in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                             uint256  bytes  0                                                             -  32 len(executeFuncSignature):          uint16   bytes  32                                                            -  34 executeFuncSignature:               bytes    bytes  34                                                            -  34 + len(executeFuncSignature) len(executeContractAddress):        uint8    bytes  34 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) executeContractAddress              bytes    bytes  35 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):        uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)  -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:             bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                      bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        executeProposal(resourceID: BytesLike, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        MAX_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        _bridgeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Blank function, required in IHandler.
         * @param args Additional data to be passed to specified handler.
         * @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.
         * @param resourceID ResourceID to be used when making deposits.
         */
        setResource(resourceID: BytesLike, contractAddress: string, args: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        /**
         * A deposit is initiated by making a deposit in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                       uint256  bytes  0                                                                                           -  32 len(executeFuncSignature):    uint16   bytes  32                                                                                          -  34 executeFuncSignature:         bytes    bytes  34                                                                                          -  34 + len(executeFuncSignature) len(executeContractAddress):  uint8    bytes  34 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) executeContractAddress        bytes    bytes  35 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):  uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:       bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param depositor Address of the account making deposit in the Bridge contract.
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        deposit(resourceID: BytesLike, depositor: string, data: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Proposal execution should be initiated when a proposal is finalized in the Bridge contract.
         * @param data Structure should be constructed as follows: maxFee:                             uint256  bytes  0                                                             -  32 len(executeFuncSignature):          uint16   bytes  32                                                            -  34 executeFuncSignature:               bytes    bytes  34                                                            -  34 + len(executeFuncSignature) len(executeContractAddress):        uint8    bytes  34 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) executeContractAddress              bytes    bytes  35 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) + len(executeContractAddress) len(executionDataDepositor):        uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)  -  36 + len(executeFuncSignature) + len(executeContractAddress) executionDataDepositor:             bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor) executionData:                      bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END executionData is repacked together with executionDataDepositor address for using it in the target contract. If executionData contains dynamic types then it is necessary to keep the offsets correct. executionData should be encoded together with a 32-byte address and then passed as a parameter without that address. If the target function accepts (address depositor, bytes executionData) then a function like the following one can be used: function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), executionData); return this.slice(encoded, 32); } function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) { return input[position:]; } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, bytes executionData) Another example: if the target function accepts (address depositor, uint[], address) then a function like the following one can be used: function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) { bytes memory encoded = abi.encode(address(0), uintArray, addr); return this.slice(encoded, 32); } After this, the target contract will get the following: executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)
         * @param resourceID ResourceID used to find address of contract to be used for deposit.
         */
        executeProposal(resourceID: BytesLike, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
