import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface TestDepositInterface extends utils.Interface {
    contractName: "TestDeposit";
    functions: {
        "prepareDepositData(bytes)": FunctionFragment;
        "slice(bytes,uint256)": FunctionFragment;
        "executePacked(address,bytes)": FunctionFragment;
        "executeUnpacked(address,uint256,address[],bytes)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "prepareDepositData", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "slice", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "executePacked", values: [string, BytesLike]): string;
    encodeFunctionData(functionFragment: "executeUnpacked", values: [string, BigNumberish, string[], BytesLike]): string;
    decodeFunctionResult(functionFragment: "prepareDepositData", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "slice", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executePacked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeUnpacked", data: BytesLike): Result;
    events: {
        "TestExecute(address,uint256,address,bytes)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "TestExecute"): EventFragment;
}
export declare type TestExecuteEvent = TypedEvent<[
    string,
    BigNumber,
    string,
    string
], {
    depositor: string;
    num: BigNumber;
    addr: string;
    message: string;
}>;
export declare type TestExecuteEventFilter = TypedEventFilter<TestExecuteEvent>;
export interface TestDeposit extends BaseContract {
    contractName: "TestDeposit";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: TestDepositInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        /**
         * This helper can be used to prepare execution data for Bridge.deposit() on the source chain if PermissionlessGenericHandler is used and if the target function accepts (address depositor, bytes executionData). The execution data (packed as bytes) will be packed together with depositorAddress in PermissionlessGenericHandler before execution on the target chain. This function packs the bytes parameter together with a fake address and removes the address. After repacking in the handler together with depositorAddress, the offsets will be correct. Usage: pack all parameters as bytes, then use this function, then pack the result of this function together with maxFee, executeFuncSignature etc and pass it to Bridge.deposit().
         */
        prepareDepositData(executionData: BytesLike, overrides?: CallOverrides): Promise<[string]>;
        slice(input: BytesLike, position: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        executePacked(depositor: string, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        executeUnpacked(depositor: string, num: BigNumberish, addresses: string[], message: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    /**
     * This helper can be used to prepare execution data for Bridge.deposit() on the source chain if PermissionlessGenericHandler is used and if the target function accepts (address depositor, bytes executionData). The execution data (packed as bytes) will be packed together with depositorAddress in PermissionlessGenericHandler before execution on the target chain. This function packs the bytes parameter together with a fake address and removes the address. After repacking in the handler together with depositorAddress, the offsets will be correct. Usage: pack all parameters as bytes, then use this function, then pack the result of this function together with maxFee, executeFuncSignature etc and pass it to Bridge.deposit().
     */
    prepareDepositData(executionData: BytesLike, overrides?: CallOverrides): Promise<string>;
    slice(input: BytesLike, position: BigNumberish, overrides?: CallOverrides): Promise<string>;
    executePacked(depositor: string, data: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    executeUnpacked(depositor: string, num: BigNumberish, addresses: string[], message: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        /**
         * This helper can be used to prepare execution data for Bridge.deposit() on the source chain if PermissionlessGenericHandler is used and if the target function accepts (address depositor, bytes executionData). The execution data (packed as bytes) will be packed together with depositorAddress in PermissionlessGenericHandler before execution on the target chain. This function packs the bytes parameter together with a fake address and removes the address. After repacking in the handler together with depositorAddress, the offsets will be correct. Usage: pack all parameters as bytes, then use this function, then pack the result of this function together with maxFee, executeFuncSignature etc and pass it to Bridge.deposit().
         */
        prepareDepositData(executionData: BytesLike, overrides?: CallOverrides): Promise<string>;
        slice(input: BytesLike, position: BigNumberish, overrides?: CallOverrides): Promise<string>;
        executePacked(depositor: string, data: BytesLike, overrides?: CallOverrides): Promise<void>;
        executeUnpacked(depositor: string, num: BigNumberish, addresses: string[], message: BytesLike, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "TestExecute(address,uint256,address,bytes)"(depositor?: null, num?: null, addr?: null, message?: null): TestExecuteEventFilter;
        TestExecute(depositor?: null, num?: null, addr?: null, message?: null): TestExecuteEventFilter;
    };
    estimateGas: {
        /**
         * This helper can be used to prepare execution data for Bridge.deposit() on the source chain if PermissionlessGenericHandler is used and if the target function accepts (address depositor, bytes executionData). The execution data (packed as bytes) will be packed together with depositorAddress in PermissionlessGenericHandler before execution on the target chain. This function packs the bytes parameter together with a fake address and removes the address. After repacking in the handler together with depositorAddress, the offsets will be correct. Usage: pack all parameters as bytes, then use this function, then pack the result of this function together with maxFee, executeFuncSignature etc and pass it to Bridge.deposit().
         */
        prepareDepositData(executionData: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        slice(input: BytesLike, position: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        executePacked(depositor: string, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        executeUnpacked(depositor: string, num: BigNumberish, addresses: string[], message: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        /**
         * This helper can be used to prepare execution data for Bridge.deposit() on the source chain if PermissionlessGenericHandler is used and if the target function accepts (address depositor, bytes executionData). The execution data (packed as bytes) will be packed together with depositorAddress in PermissionlessGenericHandler before execution on the target chain. This function packs the bytes parameter together with a fake address and removes the address. After repacking in the handler together with depositorAddress, the offsets will be correct. Usage: pack all parameters as bytes, then use this function, then pack the result of this function together with maxFee, executeFuncSignature etc and pass it to Bridge.deposit().
         */
        prepareDepositData(executionData: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        slice(input: BytesLike, position: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        executePacked(depositor: string, data: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        executeUnpacked(depositor: string, num: BigNumberish, addresses: string[], message: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
